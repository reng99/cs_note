# 时间复杂度

一个算法的优劣可以用**空间复杂度**和**时间复杂度**来衡量。

> 时间复杂度：评估执行程序所需的时间。可以估算出程序对处理器的使用程度。

> 空间复杂度：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。

算法设计时，时间复杂要比空间复杂度更容易复杂。没有特殊说明，`复杂度指时间复杂度`

**一个算法在执行过程中所消耗的时间取决于下面的因素：**

1. 算法所需数据输入的时间
2. 算法编译为可执行程序的时间
3. 计算机执行每条指令所需的时间
4. 算法语句重复执行的次数

上面的因素中，`1`依赖于输入设备的性能，若是[脱机]([https://baike.baidu.com/item/%E8%84%B1%E6%9C%BA%E5%A4%84%E7%90%86/10173514?fr=aladdin](https://baike.baidu.com/item/脱机处理/10173514?fr=aladdin))输入，则输入数据的时间可以忽略不计；`2, 3`取决于计算机本身执行的速度和编译程序的性能。因此，习惯上将**算法语句重复执行的次数**作为算法的时间度量。

比如：

```javascript
// 'x = x + 1'执行一次
function add(x, y){
  x = x + 1
}

// 'x = x + 1'执行n次
function map_add(x, n) {
  for(let i = 0; i < n; i++){
    x = x + 1
  }
}

// 'x = x + 1'执行n²
function loop_add(x, n) {
  for(let i = 0; i < n; i++) {
    for(let j = 0; j < n; j++) {
      x = x + 1
    }
  }
}
```

上面功能代码只是演示了下`x + 1`执行的次数**(频度)**，那上面的功能代码总共执行了多少次呢？见下面：

```javascript
function add(x, y){
  x = x + 1 // 执行1次
  // 总执行1次
}

function map_add(x, n) {
  for(let i = 0; i < n; i++) { // 执行n+1次
    x = x + 1 // 执行n 次
  }
  // 总执行(n+1)+n，即2n+1次
}

function loop_add(x, n) {
  for(let i = 0; i < n; i++) { // 执行n+1次
    for(let j = 0; j < n; j++) { // 执行n*(n+1)次
      x = x + 1 // 执行 n*n
    }
  }
    // 总执行(n+1)+n*(n+1)+n*n，即2n²+2n+1
}
```

> :warning: 时间频度： 一个算法中的语句执行次数称为语句频度或时间频度。

这就涉及到**大O记号**表示算法的的时间性能了。

推导**大O阶**，按照下面的三个规则来推导：

1、运行时间中所有的`加减法常数`用常数1代替

2、只保留最高阶项

3、去除最高项常数

下面对几个常见的时间复杂度说明下：

### O(1)常数阶

```javascript
temp = i;
i = j;
j = temp;
```

以上三条单语句的频度均为`1`，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作`T(n)=O(1)`。

> :warning: 如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是`O(1)`

### O(n)线性阶

线性阶主要分析循环结构的运行情况，如下：

```javascript
a = 0; b = 1; ①
for(i = 1; i <= n; i++) ②
{
  s = a + b; ③
  b = a; ④
  a = s; ⑤
}
```

- 语句①的频度是：2
- 语句②的频度是：n
- 语句③的频度是：n-1
- 语句④的频度是：n-1
- 语句⑤的频度是：n-1 

循环体内的`③、④、⑤`都是`O(1)`常数阶。

`T(n) = 2+n+3(n-1) = 4n-1 = O(n)` 即 **T(n) = O(n)**

### O(n²)平方阶

平方阶一般出现在嵌套的循环中，如下：

```javascript
for(i = 1; i < n; i++)
{
  y = y + 1; ①
  for(j = 0; j <= 2n; j++)
    x++; ②
}
```

- 语句①的频度是：n-1
- 语句②的频度是：(n-1)*(2n+1) = 2n²-n-1

则有：`f(n) = n-1+2n²-n-1 = 2n²-2` => `O(2n²-2) = n²` 即有 **T(n)=O(n2)**

> :warning: 当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的`频度f(n)`决定的。

### O(n3)立方阶

应用上面`O(n²)平方阶`的注意规则，可以得到下面三层嵌套的`大O阶`表示法。

```javascript
for(i=0;i<n;i++)
{  
  for(j=0;j<i;j++)  
  {
    for(k=0;k<j;k++)
        x=x+2;  ①
  }
}
```

时间复杂度为`O(n3)`。

### O(logn)对数阶

```javascript
i = 1; ①
while(i < n)
  i = i * 2; ②
```

- 语句①的频度是：1
- 语句②的频度：`2^f(n) <= n` => `f(n) <= log₂n` => 取最大值`log₂n`

则有`T(n) = 1 + log₂n = O(log₂n)` 即 **T(n) = O(log₂n)**

### 其他的常见时间复杂度

f(n)=nlogn时，时间复杂度为O(nlogn)，可以称为nlogn阶。

f(n)=2ⁿ时，时间复杂度为O(2ⁿ)，可以称为指数阶。

f(n)=n!时，时间复杂度为O(n!)，可以称为阶乘阶。

f(n)=(√n时，时间复杂度为O(√n)，可以称为平方根阶

### 时间复杂度的比较

如下图：

![time_complexity](./imgs/time_complexity.png "border_img_time_complexity")

通过图片很直观的得到常用的时间复杂度按照消耗时间的多少从少到多排序依次是：

**O(1) < O(logn) < O(√n) < O(n) < O(nlogn) < O(n²) < O(n³) < O(2ⁿ) < O(n!)**

### 参考链接

- https://baijiahao.baidu.com/s?id=1609024533531824968&wfr=spider&for=pc
- https://blog.csdn.net/qq_30815237/article/details/90766878
- https://blog.csdn.net/zolalad/article/details/11848739