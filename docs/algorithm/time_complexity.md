# 時間複雜度
一個算法的優劣可以用**空間複雜度**和**時間複雜度**來衡量。

> 時間復雜度：評估執行程序所需的時間。可以估算出程序對處理器的使用程度。

> 空間復雜度：評估執行程序所需的存儲空間。可以估算出程序對計算機內存的使用程度。

算法設計時，時間復雜要比空間復雜度更容易復雜。沒有特殊說明，`復雜度指時間復雜度`

**壹個算法在執行過程中所消耗的時間取決於下面的因素：**

1. 算法所需數據輸入的時間
2. 算法編譯為可執行程序的時間
3. 計算機執行每條指令所需的時間
4. 算法語句重復執行的次數

上面的因素中，`1`依賴於輸入設備的性能，若是[脫機]([https://baike.baidu.com/item/%E8%84%B1%E6%9C%BA%E5%A4%84%E7%90%86/10173514?fr=aladdin](https://baike.baidu.com/item/脫機處理/10173514?fr=aladdin))輸入，則輸入數據的時間可以忽略不計；`2, 3`取決於計算機本身執行的速度和編譯程序的性能。因此，習慣上將**算法語句重復執行的次數**作為算法的時間度量。

比如：

```javascript
// 'x = x + 1'執行1次
function add(x, y){
  x = x + 1
}

// 'x = x + 1'執行n次
function map_add(x, n) {
  for(let i = 0; i < n; i++){
    x = x + 1
  }
}

// 'x = x + 1'執行n²
function loop_add(x, n) {
  for(let i = 0; i < n; i++) {
    for(let j = 0; j < n; j++) {
      x = x + 1
    }
  }
}
```

上面功能代碼只是演示了下`x + 1`執行的次數**(頻度)**，那上面的功能代碼總共執行了多少次呢？見下面：

```javascript
function add(x, y){
  x = x + 1 // 執行1次
  // 總執行1次
}

function map_add(x, n) {
  for(let i = 0; i < n; i++) { // 執行n+1次
    x = x + 1 // 執行 n 次
  }
  // 總執行n+1)+n，即2n+1次
}

function loop_add(x, n) {
  for(let i = 0; i < n; i++) { // 執行n+1次
    for(let j = 0; j < n; j++) { // 執行n*(n+1)次
      x = x + 1 // 執行 n*n
    }
  }
    // 執行(n+1)+n*(n+1)+n*n，即2n²+2n+1
}
```

> :warning: 時間頻度： 壹個算法中的語句執行次數稱為語句頻度或時間頻度。

這就涉及到**大O記號**表示算法的的時間性能了。

推導**大O階**，按照下面的三個規則來推導：

1、運行時間中所有的`加減法常數`用常數1代替

2、只保留最高階項

3、去除最高項常數

下面對幾個常見的時間復雜度說明下：

### O(1)常數階

```javascript
temp = i;
i = j;
j = temp;
```

以上三條單語句的頻度均為`1`，該程序段的執行時間是壹個與問題規模n無關的常數。算法的時間復雜度為常數階，記作`T(n)=O(1)`。

> :warning: 如果算法的執行時間不隨著問題規模n的增加而增長，即使算法中有上千條語句，其執行時間也不過是壹個較大的常數。此類算法的時間復雜度是`O(1)`

### O(n)線性階

線性階主要分析循環結構的運行情況，如下：

```javascript
a = 0; b = 1; ①
for(i = 1; i <= n; i++) ②
{
  s = a + b; ③
  b = a; ④
  a = s; ⑤
}
```

- 語句①的頻度是：2
- 語句②的頻度是：n
- 語句③的頻度是：n-1
- 語句④的頻度是：n-1
- 語句⑤的頻度是：n-1 

循環體內的`③、④、⑤`都是`O(1)`常數階。

`T(n) = 2+n+3(n-1) = 4n-1 = O(n)` 即 **T(n) = O(n)**

### O(n²)平方階

平方階壹般出現在嵌套的循環中，如下：

```javascript
for(i = 1; i < n; i++)
{
  y = y + 1; ①
  for(j = 0; j <= 2n; j++)
    x++; ②
}
```

- 語句①的頻度是：n-1
- 語句②的頻度是：(n-1)*(2n+1) = 2n²-n-1

則有：`f(n) = n-1+2n²-n-1 = 2n²-2` => `O(2n²-2) = n²` 即有 **T(n)=O(n2)**

> :warning: 當有若幹個循環語句時，算法的時間復雜度是由嵌套層數最多的循環語句中最內層語句的`頻度f(n)`決定的。

### O(n3)立方階

應用上面`O(n²)平方階`的註意規則，可以得到下面三層嵌套的`大O階`表示法。

```javascript
for(i=0;i<n;i++)
{  
  for(j=0;j<i;j++)  
  {
    for(k=0;k<j;k++)
        x=x+2;  ①
  }
}
```

時間復雜度為`O(n3)`。

### O(logn)對數階

```javascript
i = 1; ①
while(i < n)
  i = i * 2; ②
```

- 語句①的頻度是：1
- 語句②的頻度：`2^f(n) <= n` => `f(n) <= log₂n` => 取最大值`log₂n`

則有`T(n) = 1 + log₂n = O(log₂n)` 即 **T(n) = O(log₂n)**

### 其他的常見時間復雜度

f(n)=nlogn時，時間復雜度為O(nlogn)，可以稱為nlogn階。

f(n)=2ⁿ時，時間復雜度為O(2ⁿ)，可以稱為指數階。

f(n)=n!時，時間復雜度為O(n!)，可以稱為階乘階。

f(n)=(√n時，時間復雜度為O(√n)，可以稱為平方根階

### 時間復雜度的比較

如下圖：

![time_complexity](./imgs/time_complexity.png "border_img_time_complexity")

通過圖片很直觀的得到常用的時間復雜度按照消耗時間的多少從少到多排序依次是：

**O(1) < O(logn) < O(√n) < O(n) < O(nlogn) < O(n²) < O(n³) < O(2ⁿ) < O(n!)**

### 參考鏈接

- https://baijiahao.baidu.com/s?id=1609024533531824968&wfr=spider&for=pc
- https://blog.csdn.net/qq_30815237/article/details/90766878
- https://blog.csdn.net/zolalad/article/details/11848739